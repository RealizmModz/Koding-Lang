{
  "version": 3,
  "sources": ["../../frontend/parser.ts"],
  "sourcesContent": ["import {\n  BinaryExpr,\n  Expr,\n  Identifier,\n  NullLiteral,\n  NumericLiteral,\n  Program,\n  Stmt,\n} from \"./ast.ts\";\n\nimport { Token, tokenize, TokenType } from \"./lexer.ts\";\n\nexport default class Parser {\n  private tokens: Token[] = [];\n\n  private not_eof(): boolean {\n    return this.tokens[0].type != TokenType.EOF;\n  }\n\n  private at() {\n    return this.tokens[0] as Token;\n  }\n\n  private eat() {\n    const prev = this.tokens.shift() as Token;\n    return prev;\n  }\n\n  private expect(type: TokenType, err: any) {\n    const prev = this.tokens.shift() as Token;\n    if (!prev || prev.type != type) {\n      console.error(\"Parser Error:\\n\", err, prev, \" - Expecting: \", type);\n      Deno.exit(1);\n    }\n\n    return prev;\n  }\n\n  public produceAST(sourceCode: string): Program {\n    this.tokens = tokenize(sourceCode);\n    const program: Program = {\n      kind: \"Program\",\n      body: [],\n    };\n\n    while (this.not_eof()) {\n      program.body.push(this.parse_stmt());\n    }\n\n    return program;\n  }\n\n  private parse_stmt(): Stmt {\n    return this.parse_expr();\n  }\n\n  private parse_expr(): Expr {\n    return this.parse_additive_expr();\n  }\n\n  private parse_additive_expr(): Expr {\n    let left = this.parse_multiplicitave_expr();\n\n    while (this.at().value == \"+\" || this.at().value == \"-\") {\n      const operator = this.eat().value;\n      const right = this.parse_multiplicitave_expr();\n      left = {\n        kind: \"BinaryExpr\",\n        left,\n        right,\n        operator,\n      } as BinaryExpr;\n    }\n\n    return left;\n  }\n\n  private parse_multiplicitave_expr(): Expr {\n    let left = this.parse_primary_expr();\n\n    while (\n      this.at().value == \"/\" || this.at().value == \"*\" || this.at().value == \"%\"\n    ) {\n      const operator = this.eat().value;\n      const right = this.parse_primary_expr();\n      left = {\n        kind: \"BinaryExpr\",\n        left,\n        right,\n        operator,\n      } as BinaryExpr;\n    }\n\n    return left;\n  }\n\n  private parse_primary_expr(): Expr {\n    const tk = this.at().type;\n\n    switch (tk) {\n      case TokenType.Identifier:\n        return { kind: \"Identifier\", symbol: this.eat().value } as Identifier;\n\n      case TokenType.Null:\n        this.eat();\n        return { kind: \"NullLiteral\", value: \"null\" } as NullLiteral;\n\n      case TokenType.Number:\n        return {\n          kind: \"NumericLiteral\",\n          value: parseFloat(this.eat().value),\n        } as NumericLiteral;\n\n      case TokenType.OpenParen: {\n        this.eat();\n        const value = this.parse_expr();\n        this.expect(\n          TokenType.CloseParen,\n          \"Unexpected token found inside parenthesised expression. Expected closing parenthesis.\",\n        );\n        return value;\n      }\n\n      default:\n        console.error(\"Unexpected token found during parsing!\", this.at());\n        Deno.exit(1);\n    }\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA,mBAA2C;AAE3C,MAAO,OAAqB;AAAA,EAA5B;AACE,SAAQ,SAAkB,CAAC;AAAA;AAAA,EAEnB,UAAmB;AACzB,WAAO,KAAK,OAAO,GAAG,QAAQ,uBAAU;AAAA,EAC1C;AAAA,EAEQ,KAAK;AACX,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEQ,MAAM;AACZ,UAAM,OAAO,KAAK,OAAO,MAAM;AAC/B,WAAO;AAAA,EACT;AAAA,EAEQ,OAAO,MAAiB,KAAU;AACxC,UAAM,OAAO,KAAK,OAAO,MAAM;AAC/B,QAAI,CAAC,QAAQ,KAAK,QAAQ,MAAM;AAC9B,cAAQ,MAAM,mBAAmB,KAAK,MAAM,kBAAkB,IAAI;AAClE,WAAK,KAAK,CAAC;AAAA,IACb;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,WAAW,YAA6B;AAC7C,SAAK,aAAS,uBAAS,UAAU;AACjC,UAAM,UAAmB;AAAA,MACvB,MAAM;AAAA,MACN,MAAM,CAAC;AAAA,IACT;AAEA,WAAO,KAAK,QAAQ,GAAG;AACrB,cAAQ,KAAK,KAAK,KAAK,WAAW,CAAC;AAAA,IACrC;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAmB;AACzB,WAAO,KAAK,WAAW;AAAA,EACzB;AAAA,EAEQ,aAAmB;AACzB,WAAO,KAAK,oBAAoB;AAAA,EAClC;AAAA,EAEQ,sBAA4B;AAClC,QAAI,OAAO,KAAK,0BAA0B;AAE1C,WAAO,KAAK,GAAG,EAAE,SAAS,OAAO,KAAK,GAAG,EAAE,SAAS,KAAK;AACvD,YAAM,WAAW,KAAK,IAAI,EAAE;AAC5B,YAAM,QAAQ,KAAK,0BAA0B;AAC7C,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,4BAAkC;AACxC,QAAI,OAAO,KAAK,mBAAmB;AAEnC,WACE,KAAK,GAAG,EAAE,SAAS,OAAO,KAAK,GAAG,EAAE,SAAS,OAAO,KAAK,GAAG,EAAE,SAAS,KACvE;AACA,YAAM,WAAW,KAAK,IAAI,EAAE;AAC5B,YAAM,QAAQ,KAAK,mBAAmB;AACtC,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,qBAA2B;AACjC,UAAM,KAAK,KAAK,GAAG,EAAE;AAErB,YAAQ,IAAI;AAAA,MACV,KAAK,uBAAU;AACb,eAAO,EAAE,MAAM,cAAc,QAAQ,KAAK,IAAI,EAAE,MAAM;AAAA,MAExD,KAAK,uBAAU;AACb,aAAK,IAAI;AACT,eAAO,EAAE,MAAM,eAAe,OAAO,OAAO;AAAA,MAE9C,KAAK,uBAAU;AACb,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO,WAAW,KAAK,IAAI,EAAE,KAAK;AAAA,QACpC;AAAA,MAEF,KAAK,uBAAU,WAAW;AACxB,aAAK,IAAI;AACT,cAAM,QAAQ,KAAK,WAAW;AAC9B,aAAK;AAAA,UACH,uBAAU;AAAA,UACV;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,MAEA;AACE,gBAAQ,MAAM,0CAA0C,KAAK,GAAG,CAAC;AACjE,aAAK,KAAK,CAAC;AAAA,IACf;AAAA,EACF;AACF;",
  "names": []
}
